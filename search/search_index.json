{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Getting started","text":"<p>floquet  is a python package for performing floquet simulations on quantum systems to identify nonlinear resonances.</p>"},{"location":"#installation","title":"Installation","text":"<p>For now we support only installing directly from github <pre><code>pip install git+https://github.com/dkweiss31/floquet\n</code></pre></p> <p>Requires Python 3.10+</p>"},{"location":"#example","title":"Example","text":"<p>Before jumping straight into the Floquet analysis, we first need to define our system Hamiltonian and the drive parameters. Here we take the example of a transmon and utilize the scubits library to help define the system Hamiltonian. Note however that the code accepts QuTiP <code>Qobj</code> as input for the Hamiltonian.  <pre><code>num_states = 20\nqubit_params = {\"EJ\": 20.0, \"EC\": 0.2, \"ng\": 0.25, \"ncut\": 41}\ntmon = scq.Transmon(**qubit_params, truncated_dim=num_states)\nhilbert_space = scq.HilbertSpace([tmon])\nhilbert_space.generate_lookup()\nevals = hilbert_space[\"evals\"][0][0:num_states]\n# Define the Hamiltonian of the transmon in its eigenbasis, in which H0 is diagonal\nH0 = 2.0 * np.pi * qt.Qobj(np.diag(evals - evals[0]))\n# Use this helper method to define the charge-number operator in the dressed eigenbasis \nH1 = hilbert_space.op_in_dressed_eigenbasis(tmon.n_operator)\n</code></pre> We then also need to specify the drive frequencies we plan to drive at, which correspond to the cavity frequencies <pre><code>omega_d_values = 2.0 * np.pi * np.linspace(7.5, 10.0, 120)\n</code></pre> Finally, we specify the induced ac-stark shift that we want the qubit to experience. The dispersive coupling of a qubit to the cavity differs as a function of the cavity frequency. Thus we provide helper functions for normalizing the drive amplitudes so that we scan over the same induced ac-Stark shifts for all given frequencies.  <pre><code>import floquet as ft\n\nstate_indices = [0, 1]  # get data for ground and first excited states\nchi_ac_linspace = 2.0 * np.pi * np.linspace(0.0, 0.1, 59) # 100 MHz ac-Stark shift\nchi_to_amp = ft.ChiacToAmp(H0, H1, state_indices, omega_d_values)\ndrive_amplitudes = chi_to_amp.amplitudes_for_omega_d(chi_ac_linspace)\n</code></pre> We can now pass these derived quantities to <code>Model</code> which specifies the model system <pre><code>model = ft.Model(\n    H0, H1, omega_d_values=omega_d_values, drive_amplitudes=drive_amplitudes\n)\n</code></pre> We are now ready to create an instance of the <code>FloquetAnalysis</code> class, and run the full Floquet simulation <pre><code>options = ft.Options(num_cpus=6)\nfloquet_analysis = ft.FloquetAnalysis(model, state_indices=state_indices, options=options)\ndata_vals = floquet_analysis.run()\n</code></pre> <code>data_vals</code> is a dictionary containing all quantities computed during the call to <code>run()</code>. This includes the overlap with the \"ideal\" displaced state, which can be plotted to reveal \"scars\" in the drive frequency and amplitude space where resonances occur. This part of the analysis is based on Xiao, Venkatraman et al, arXiv (2023), see Appendices I and J. Additionally we perform a so-called branch analysis to understand which states are responsible for ionization, based on Dumas et al, arXiv 2024. See the tutorial notebooks under Examples on the left for example applications of the analysis, how to plot and visualize the computed quantities, etc.</p>"},{"location":"#citation","title":"Citation","text":"<p>If you found this package useful in academic work, please cite</p> <pre><code>@misc{floquet2024,\n  title  = {Floquet: Identifying nonlinear resonances in quantum systems due to parametric drives},\n  author = {Daniel K. Weiss},\n  year   = {2024},\n  howpublished    = {\\url{https://github.com/dkweiss31/floquet}}\n}\n</code></pre> <p>Also please consider starring the project on github!</p>"},{"location":"FAQ/","title":"FAQ","text":""},{"location":"FAQ/#how-do-i-read-my-saved-data","title":"How do I read my saved data?","text":"<p>If you have run a previous simulation where you saved your data to <code>\"foo.h5py\"</code>, by calling e.g.</p> <p>data_vals = floquet_analysis.run(filepath=\"foo.h5py\") # doctest: +SKIP</p> <p>the saved data and <code>FloquetAnalysis</code> instance that was used to produce this data can be read by calling</p> <p>read_floquet_instance, read_data = ft.read_from_file(\"foo.h5py\") # doctest: +SKIP</p>"},{"location":"FAQ/#im-seeing-weird-artifacts-in-the-displaced-state-overlap-plots","title":"I'm seeing weird artifacts in the displaced state overlap plots","text":"<p>This issue occurs because the floquet mode has been displaced far from the origin, causing the overlap of the floquet mode with the bare state to fall below the threshold <code>overlap_cutoff</code>. This issue typically can be dealt with by decreasing <code>fit_range_fraction</code> from 1.0 to e.g. 0.5 or 0.25 (note that the fraction doesn't need to evenly divide 1.0). If 0.5 is chosen, the ideal-displaced-state fitting restarts after the first half of the drive amplitude values. The displaced state fitted from the first half range is then utilized to calculate overlaps for the states in the second half range. <code>fit_range_fraction</code> can be reduced arbitrarily, but beware of decreasing it too much or there won't be enough data to generate a faithful fit of the true displaced state.</p>"},{"location":"floquet/","title":"Python API","text":"<p>The floquet Python API consists largely of the floquet_analysis function which initializes a FloquetAnalysis class. We can then call <code>run(filepath)</code> on instances of this class to perform the Floquet simulation. The computed data is then saved both as attributes of the class and also to the file specified by <code>filepath</code>, which should be a string specifying a <code>h5py</code> file.</p>"},{"location":"floquet/#floquet-methods","title":"Floquet methods","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis","title":"<code>FloquetAnalysis</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Perform a floquet analysis to identify nonlinear resonances.</p> <p>In most workflows, one needs only to call the run() method which performs both the displaced state fit and the Blais branch analysis. For an example workflow, see the transmon tutorial.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>Class specifying the model, including the Hamiltonian, drive amplitudes, frequencies</p> required <code>state_indices</code> <code>list | None</code> <p>State indices of interest. Defaults to [0, 1], indicating the two lowest-energy states.</p> <code>None</code> <code>options</code> <code>Options</code> <p>Options for the Floquet analysis.</p> <code>Options()</code> <code>init_data_to_save</code> <code>dict | None</code> <p>Initial parameter metadata to save to file. Defaults to None.</p> <code>None</code>"},{"location":"floquet/#floquet.floquet.FloquetAnalysis.model","title":"<code>model = model</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.state_indices","title":"<code>state_indices = state_indices</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.options","title":"<code>options = options</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.init_data_to_save","title":"<code>init_data_to_save = init_data_to_save</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.hilbert_dim","title":"<code>hilbert_dim = model.H0.shape[0]</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.__init__","title":"<code>__init__(model: Model, state_indices: list | None = None, options: Options = Options(), init_data_to_save: dict | None = None)</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.run_one_floquet","title":"<code>run_one_floquet(omega_d_amp: tuple[float, float]) -&gt; tuple[np.ndarray, qt.Qobj]</code>","text":"<p>Run one instance of the problem for a pair of drive frequency and amp.</p> <p>Returns floquet modes as numpy column vectors, as well as the quasienergies.</p> <p>Parameters:</p> Name Type Description Default <code>omega_d_amp</code> <code>tuple[float, float]</code> <p>Pair of drive frequency and amp.</p> required"},{"location":"floquet/#floquet.floquet.FloquetAnalysis.identify_floquet_modes","title":"<code>identify_floquet_modes(f_modes_energies: tuple[np.ndarray, qt.Qobj], params_0: tuple[float, float], displaced_state: DisplacedState, previous_coefficients: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Return floquet modes with largest overlap with ideal displaced state.</p> <p>Also return that overlap value.</p> <p>Parameters:</p> Name Type Description Default <code>f_modes_energies</code> <code>tuple[ndarray, Qobj]</code> <p>output of self.run_one_floquet(params)</p> required <code>params_0</code> <code>tuple[float, float]</code> <p>(omega_d_0, amp_0) to use for displaced fit</p> required <code>displaced_state</code> <code>DisplacedState</code> <p>Instance of DisplacedState</p> required <code>previous_coefficients</code> <code>ndarray</code> <p>Coefficients from the previous amplitude range that will be used when calculating overlap of the floquet modes against the 'bare' states specified by previous_coefficients</p> required"},{"location":"floquet/#floquet.floquet.FloquetAnalysis.bare_state_array","title":"<code>bare_state_array() -&gt; np.ndarray</code>","text":"<p>Return array of bare states.</p> <p>Used to specify initial bare states for the Blais branch analysis.</p>"},{"location":"floquet/#floquet.floquet.FloquetAnalysis.run","title":"<code>run(filepath: str | None = None) -&gt; dict</code>","text":"<p>Perform floquet analysis over range of amplitudes and drive frequencies.</p> <p>This function largely performs two calculations. The first is the Xiao analysis introduced in https://arxiv.org/abs/2304.13656, fitting the extracted Floquet modes to the \"ideal\" displaced state which does not include resonances by design (because we fit to a low order polynomial and ignore any floquet modes with overlap with the bare state below a given threshold). This analysis produces the \"scar\" plots. The second is the Blais branch analysis, which tracks the Floquet modes by stepping in drive amplitude for a given drive frequency. For this reason the code is structured to parallelize over drive frequency, but scans in a loop over drive amplitude. This way the two calculations can be performed simultaneously.</p> <p>A nice bonus is that both of the above mentioned calculations determine essentially independently whether a resonance occurs. In the first, it is deviation of the Floquet mode from the fitted displaced state. In the second, it is branch swapping that indicates a resonance, independent of any fit. Thus the two simulations can be used for cross validation of one another.</p> <p>We perform these simulations iteratively over the drive amplitudes as specified by fit_range_fraction. This is to allow for simulations stretching to large drive amplitudes, where the overlap with the bare eigenstate would fall below the threshold (due to ac Stark shift) even in the absence of any resonances. We thus use the fit from the previous range of drive amplitudes as our new bare state.</p>"},{"location":"floquet/#floquet.floquet.FloquetAnalysis.__new__","title":"<code>__new__(*args, **kwargs) -&gt; Serializable</code>","text":"<p>Records which parameters should be saved so they can be passed to init.</p>"},{"location":"floquet/#floquet.floquet.FloquetAnalysis.__eq__","title":"<code>__eq__(other: Serializable) -&gt; bool</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.__hash__","title":"<code>__hash__() -&gt; int</code>","text":""},{"location":"floquet/#floquet.floquet.FloquetAnalysis.serialize","title":"<code>serialize() -&gt; dict</code>","text":"<p>Serialize a class so that it is ready to be written.</p> <p>This method creates nested dictionaries appropriate for writing to h5 files. Importantly, we save metadata associated with the class itself and any classes it takes as input so that they can be reinstantiated later.</p> <p>Returns:</p> Name Type Description <code>initdata</code> <code>dict</code> <p>Dictionary of data to save, in a format appropriate to pass to h5</p>"},{"location":"floquet/#floquet.floquet.FloquetAnalysis.write_to_file","title":"<code>write_to_file(filepath: str | pathlib.Path, data_dict: dict | None = None)</code>","text":"<p>Write a class and associated data to file.</p> <p>The goal is to be able to read back both the data that was saved and all of the data necessary to reinitialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>Path to the file where we want to save the data. Must be an h5 or h5py file</p> required <code>data_dict</code> <code>dict | None</code> <p>Dictionary containing various raw data to save</p> <code>None</code>"},{"location":"floquet/#displaced-state","title":"Displaced state","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedState","title":"<code>DisplacedState</code>","text":"<p>Class providing methods for computing displaced states.</p> <p>Parameters:</p> Name Type Description Default <code>hilbert_dim</code> <code>int</code> <p>Hilbert space dimension</p> required <code>model</code> <code>Model</code> <p>Model including the Hamiltonian, drive amplitudes, frequencies, state indices</p> required <code>state_indices</code> <code>list</code> <p>States of interest</p> required <code>options</code> <code>Options</code> <p>Options used</p> required"},{"location":"floquet/#floquet.displaced_state.DisplacedState.hilbert_dim","title":"<code>hilbert_dim = hilbert_dim</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedState.model","title":"<code>model = model</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedState.state_indices","title":"<code>state_indices = state_indices</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedState.options","title":"<code>options = options</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedState.exponent_pair_idx_map","title":"<code>exponent_pair_idx_map = self._create_exponent_pair_idx_map()</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedState.__init__","title":"<code>__init__(hilbert_dim: int, model: Model, state_indices: list, options: Options)</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedState.overlap_with_bare_states","title":"<code>overlap_with_bare_states(amp_idx_0: int, coefficients: np.ndarray, floquet_modes: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Calculate overlap of floquet modes with 'bare' states.</p> <p>'Bare' here is defined loosely. For the first range of amplitudes, the bare states are truly the bare states (the coefficients are obtained from bare_state_coefficients, which give the bare states). For later ranges, we define the bare state as the state obtained from the fit from previous range, with amplitude evaluated at the lower edge of amplitudes for the new region. This is, in a sense, the most natural choice, since it is most analogous to what is done in the first window when the overlap is computed against bare eigenstates (that obviously don't have amplitude dependence). Moreover, the fit coefficients for the previous window by definition were obtained in a window that does not include the one we are currently investigating. Asking for the state with amplitude values outside of the fit window should be done at your own peril.</p> <p>Parameters:</p> Name Type Description Default <code>amp_idx_0</code> <code>int</code> <p>Index specifying the lower bound of the amplitude range.</p> required <code>coefficients</code> <code>ndarray</code> <p>coefficients that specify the bare state that we calculate overlaps of Floquet modes against</p> required <code>floquet_modes</code> <code>ndarray</code> <p>Floquet modes to be compared to the bare states given by coefficients</p> required <p>Returns:     overlaps with shape (w,a,s) where w is the number of drive frequencies,         a is the number of drive amplitudes (specified by amp_idxs) and s is the         number of states we are investigating</p>"},{"location":"floquet/#floquet.displaced_state.DisplacedState.overlap_with_displaced_states","title":"<code>overlap_with_displaced_states(amp_idxs: list, coefficients: np.ndarray, floquet_modes: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Calculate overlap of floquet modes with 'ideal' displaced states.</p> <p>This is done here for a specific amplitude range.</p> <p>Parameters:</p> Name Type Description Default <code>amp_idxs</code> <code>list</code> <p>list of lower and upper amplitude indices specifying the range of drive amplitudes this calculation should be done for</p> required <code>coefficients</code> <code>ndarray</code> <p>coefficients that specify the displaced state that we calculate overlaps of Floquet modes against</p> required <code>floquet_modes</code> <code>ndarray</code> <p>Floquet modes to be compared to the displaced states given by coefficients</p> required <p>Returns:     overlaps with shape (w,a,s) where w is the number of drive frequencies,         a is the number of drive amplitudes (specified by amp_idxs) and s is the         number of states we are investigating</p>"},{"location":"floquet/#floquet.displaced_state.DisplacedState.bare_state_coefficients","title":"<code>bare_state_coefficients(state_idx: int) -&gt; np.ndarray</code>","text":"<p>For bare state only component is itself.</p> <p>Parameters:</p> Name Type Description Default <code>state_idx</code> <code>int</code> <p>Coefficients for the state \\(|state_idx\\rangle\\) that when evaluated at any amplitude or frequency simply return the bare state. Note that this should be the actual state index, and not the array index (for instance if we have state_indices=[0, 1, 3] because we're not interested in the second excited state, for the 3rd excited state we should pass 3 here and not 2).</p> required"},{"location":"floquet/#floquet.displaced_state.DisplacedState.displaced_state","title":"<code>displaced_state(omega_d: float, amp: float, state_idx: int, coefficients: np.ndarray) -&gt; qt.Qobj</code>","text":"<p>Construct the ideal displaced state based on a polynomial expansion.</p>"},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit","title":"<code>DisplacedStateFit</code>","text":"<p>               Bases: <code>DisplacedState</code></p> <p>Methods for fitting an ideal displaced state to calculated Floquet modes.</p>"},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.hilbert_dim","title":"<code>hilbert_dim = hilbert_dim</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.model","title":"<code>model = model</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.state_indices","title":"<code>state_indices = state_indices</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.options","title":"<code>options = options</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.exponent_pair_idx_map","title":"<code>exponent_pair_idx_map = self._create_exponent_pair_idx_map()</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.displaced_states_fit","title":"<code>displaced_states_fit(omega_d_amp_slice: list, ovlp_with_bare_states: np.ndarray, floquet_modes: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Perform a fit for the indicated range, ignoring specified modes.</p> <p>We loop over all states in state_indices and perform the fit for a given amplitude range. We ignore floquet modes (not included in the fit) where the corresponding value in ovlp_with_bare_states is below the threshold specified in options.</p> <p>Parameters:</p> Name Type Description Default <code>omega_d_amp_slice</code> <code>list</code> <p>Pairs of omega_d, amplitude values at which the floquet modes have been computed and which we will use as the independent variables to fit the Floquet modes</p> required <code>ovlp_with_bare_states</code> <code>ndarray</code> <p>Bare state overlaps that has shape (w, a, s) where w is drive frequency, a is drive amplitude and s is state_indices</p> required <code>floquet_modes</code> <code>ndarray</code> <p>Floquet mode array with the same shape as ovlp_with_bare_states except with an additional trailing dimension h, the Hilbert-space dimension.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>Optimized fit coefficients</p>"},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.__init__","title":"<code>__init__(hilbert_dim: int, model: Model, state_indices: list, options: Options)</code>","text":""},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.overlap_with_bare_states","title":"<code>overlap_with_bare_states(amp_idx_0: int, coefficients: np.ndarray, floquet_modes: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Calculate overlap of floquet modes with 'bare' states.</p> <p>'Bare' here is defined loosely. For the first range of amplitudes, the bare states are truly the bare states (the coefficients are obtained from bare_state_coefficients, which give the bare states). For later ranges, we define the bare state as the state obtained from the fit from previous range, with amplitude evaluated at the lower edge of amplitudes for the new region. This is, in a sense, the most natural choice, since it is most analogous to what is done in the first window when the overlap is computed against bare eigenstates (that obviously don't have amplitude dependence). Moreover, the fit coefficients for the previous window by definition were obtained in a window that does not include the one we are currently investigating. Asking for the state with amplitude values outside of the fit window should be done at your own peril.</p> <p>Parameters:</p> Name Type Description Default <code>amp_idx_0</code> <code>int</code> <p>Index specifying the lower bound of the amplitude range.</p> required <code>coefficients</code> <code>ndarray</code> <p>coefficients that specify the bare state that we calculate overlaps of Floquet modes against</p> required <code>floquet_modes</code> <code>ndarray</code> <p>Floquet modes to be compared to the bare states given by coefficients</p> required <p>Returns:     overlaps with shape (w,a,s) where w is the number of drive frequencies,         a is the number of drive amplitudes (specified by amp_idxs) and s is the         number of states we are investigating</p>"},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.overlap_with_displaced_states","title":"<code>overlap_with_displaced_states(amp_idxs: list, coefficients: np.ndarray, floquet_modes: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Calculate overlap of floquet modes with 'ideal' displaced states.</p> <p>This is done here for a specific amplitude range.</p> <p>Parameters:</p> Name Type Description Default <code>amp_idxs</code> <code>list</code> <p>list of lower and upper amplitude indices specifying the range of drive amplitudes this calculation should be done for</p> required <code>coefficients</code> <code>ndarray</code> <p>coefficients that specify the displaced state that we calculate overlaps of Floquet modes against</p> required <code>floquet_modes</code> <code>ndarray</code> <p>Floquet modes to be compared to the displaced states given by coefficients</p> required <p>Returns:     overlaps with shape (w,a,s) where w is the number of drive frequencies,         a is the number of drive amplitudes (specified by amp_idxs) and s is the         number of states we are investigating</p>"},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.bare_state_coefficients","title":"<code>bare_state_coefficients(state_idx: int) -&gt; np.ndarray</code>","text":"<p>For bare state only component is itself.</p> <p>Parameters:</p> Name Type Description Default <code>state_idx</code> <code>int</code> <p>Coefficients for the state \\(|state_idx\\rangle\\) that when evaluated at any amplitude or frequency simply return the bare state. Note that this should be the actual state index, and not the array index (for instance if we have state_indices=[0, 1, 3] because we're not interested in the second excited state, for the 3rd excited state we should pass 3 here and not 2).</p> required"},{"location":"floquet/#floquet.displaced_state.DisplacedStateFit.displaced_state","title":"<code>displaced_state(omega_d: float, amp: float, state_idx: int, coefficients: np.ndarray) -&gt; qt.Qobj</code>","text":"<p>Construct the ideal displaced state based on a polynomial expansion.</p>"},{"location":"floquet/#model","title":"Model","text":""},{"location":"floquet/#floquet.model.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Specify the model, including the Hamiltonian, drive strengths and frequencies.</p> <p>Can be subclassed to e.g. override the hamiltonian() method for a different (but still periodic!) Hamiltonian.</p> <p>Parameters:</p> Name Type Description Default <code>H0</code> <code>Qobj | ndarray | list</code> <p>Drift Hamiltonian, which must be diagonal and provided in units such that H0 can be passed directly to qutip.</p> required <code>H1</code> <code>Qobj | ndarray | list</code> <p>Drive operator, which should be unitless (for instance the charge-number operator n of the transmon). It will be multiplied by a drive amplitude that we scan over from drive_parameters.drive_amplitudes.</p> required <code>omega_d_values</code> <code>ndarray</code> <p>drive frequencies to scan over</p> required <code>drive_amplitudes</code> <code>ndarray</code> <p>amp values to scan over. Can be one dimensional in which case these amplitudes are used for all omega_d, or it can be two dimensional in which case the first dimension are the amplitudes to scan over and the second are the amplitudes for respective drive frequencies</p> required"},{"location":"floquet/#floquet.model.Model.H0","title":"<code>H0 = H0</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.model.Model.H1","title":"<code>H1 = H1</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.model.Model.omega_d_values","title":"<code>omega_d_values = omega_d_values</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.model.Model.drive_amplitudes","title":"<code>drive_amplitudes = drive_amplitudes</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.model.Model.__init__","title":"<code>__init__(H0: qt.Qobj | np.ndarray | list, H1: qt.Qobj | np.ndarray | list, omega_d_values: np.ndarray, drive_amplitudes: np.ndarray)</code>","text":""},{"location":"floquet/#floquet.model.Model.omega_d_to_idx","title":"<code>omega_d_to_idx(omega_d: float) -&gt; np.ndarray[int]</code>","text":"<p>Return index corresponding to omega_d value.</p>"},{"location":"floquet/#floquet.model.Model.amp_to_idx","title":"<code>amp_to_idx(amp: float, omega_d: float) -&gt; np.ndarray[int]</code>","text":"<p>Return index corresponding to amplitude value.</p> <p>Because the drive amplitude can depend on the drive frequency, we also must pass the drive frequency here.</p>"},{"location":"floquet/#floquet.model.Model.omega_d_amp_params","title":"<code>omega_d_amp_params(amp_idxs: list) -&gt; itertools.chain</code>","text":"<p>Return ordered chain object of the specified omega_d and amplitude values.</p>"},{"location":"floquet/#floquet.model.Model.hamiltonian","title":"<code>hamiltonian(omega_d_amp: tuple[float, float]) -&gt; list[qt.Qobj]</code>","text":"<p>Return the Hamiltonian we actually simulate.</p>"},{"location":"floquet/#floquet.model.Model.__new__","title":"<code>__new__(*args, **kwargs) -&gt; Serializable</code>","text":"<p>Records which parameters should be saved so they can be passed to init.</p>"},{"location":"floquet/#floquet.model.Model.__eq__","title":"<code>__eq__(other: Serializable) -&gt; bool</code>","text":""},{"location":"floquet/#floquet.model.Model.__hash__","title":"<code>__hash__() -&gt; int</code>","text":""},{"location":"floquet/#floquet.model.Model.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"floquet/#floquet.model.Model.serialize","title":"<code>serialize() -&gt; dict</code>","text":"<p>Serialize a class so that it is ready to be written.</p> <p>This method creates nested dictionaries appropriate for writing to h5 files. Importantly, we save metadata associated with the class itself and any classes it takes as input so that they can be reinstantiated later.</p> <p>Returns:</p> Name Type Description <code>initdata</code> <code>dict</code> <p>Dictionary of data to save, in a format appropriate to pass to h5</p>"},{"location":"floquet/#floquet.model.Model.write_to_file","title":"<code>write_to_file(filepath: str | pathlib.Path, data_dict: dict | None = None)</code>","text":"<p>Write a class and associated data to file.</p> <p>The goal is to be able to read back both the data that was saved and all of the data necessary to reinitialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>Path to the file where we want to save the data. Must be an h5 or h5py file</p> required <code>data_dict</code> <code>dict | None</code> <p>Dictionary containing various raw data to save</p> <code>None</code>"},{"location":"floquet/#amplitude-conversion-utilities","title":"Amplitude conversion utilities","text":""},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp","title":"<code>ChiacToAmp</code>","text":"<p>Convert given induced ac-stark shift values to drive amplitudes.</p> <p>Consider a qubit coupled to an oscillator with the interaction Hamiltonian \\(H_I = g(a + a^{\\dagger})(b + b^{\\dagger})\\). If the oscillator is driven to an average occupation number of \\(\\bar{n}\\), then the effective drive strength seen by the qubit is \\(\\Omega_d = 2 g \\sqrt{\\bar{n}}\\). On the other hand based on a Schrieffer-Wolff transformation, the interaction hamiltonian is \\(H^{(2)} = \\chi a^{\\dagger}ab^{\\dagger}b\\). The average induced ac-stark shift is then \\(\\chi_{ac} = \\chi \\bar{n}\\). Thus \\(\\Omega_d = 2g\\sqrt{\\chi_{\\rm ac}/\\chi}\\). Observe that since \\(\\chi \\sim g^2\\), \\(g\\) effectively cancels out and can be set to 1.</p>"},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.H0","title":"<code>H0 = H0</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.H1","title":"<code>H1 = H1</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.state_indices","title":"<code>state_indices = state_indices</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.omega_d_linspace","title":"<code>omega_d_linspace = omega_d_values</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.__init__","title":"<code>__init__(H0: qt.Qobj, H1: qt.Qobj, state_indices: list, omega_d_values: np.ndarray)</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.amplitudes_for_omega_d","title":"<code>amplitudes_for_omega_d(chi_ac_linspace: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Return drive amplitudes corresponding to \\(\\chi_{\\rm ac}\\) values.</p>"},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.compute_chis_for_omega_d","title":"<code>compute_chis_for_omega_d() -&gt; np.ndarray</code>","text":"<p>Compute chi difference for the first two states in state_indices.</p> <p>Based on the analysis in Zhu et al PRB (2013)</p>"},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.chi_ell_ellp","title":"<code>chi_ell_ellp(energies: np.ndarray, H1: np.ndarray, E_osc: float, ell: int, ellp: int) -&gt; np.ndarray</code>  <code>staticmethod</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.ChiacToAmp.chi_ell","title":"<code>chi_ell(energies: np.ndarray, H1: np.ndarray, E_osc: float, ell: int) -&gt; np.ndarray</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.XiSqToAmp","title":"<code>XiSqToAmp</code>","text":"<p>Convert given \\(|\\xi|^2\\) value into a drive amplitude.</p> <p>This is based on the equivalence \\(\\xi = 2 \\Omega_d \\omega_d / (\\omega_d^2-\\omega^2)\\), where in this definition \\(|\\xi|^2= 2 \\chi_{\\rm ac} / \\alpha\\) where \\(\\chi_{\\rm ac}\\) is the induced ac stark shift, \\(\\alpha\\) is the anharmonicity and \\(\\Omega_d\\) is the drive amplitude.</p>"},{"location":"floquet/#floquet.amplitude_converters.XiSqToAmp.H0","title":"<code>H0 = H0</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.XiSqToAmp.H1","title":"<code>H1 = H1</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.XiSqToAmp.state_indices","title":"<code>state_indices = state_indices</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.XiSqToAmp.omega_d_linspace","title":"<code>omega_d_linspace = omega_d_linspace</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.XiSqToAmp.__init__","title":"<code>__init__(H0: qt.Qobj, H1: qt.Qobj, state_indices: list, omega_d_linspace: np.ndarray)</code>","text":""},{"location":"floquet/#floquet.amplitude_converters.XiSqToAmp.amplitudes_for_omega_d","title":"<code>amplitudes_for_omega_d(xi_sq_linspace: np.ndarray) -&gt; np.ndarray</code>","text":"<p>Return drive amplitudes corresponding to \\(|\\xi|^2\\) values.</p>"},{"location":"floquet/#options","title":"Options","text":""},{"location":"floquet/#floquet.options.Options","title":"<code>Options</code>","text":"<p>               Bases: <code>Serializable</code></p> <p>Options for the floquet analysis.</p> <p>Parameters:</p> Name Type Description Default <code>fit_range_fraction</code> <code>float</code> <p>Fraction of the amplitude range to sweep over before changing the definition of the bare state to that of the fitted state from the previous range. For instance if fit_range_fraction=0.4, then the amplitude range is split up into three chunks: the first 40% of the amplitude linspace, then from 40% -&gt; 80%, then from 80% to the full range. For the first fraction of amplitudes, they are compared to the bare eigenstates for identification. For the second range, they are compared to the fitted state from the first range. And so on. Defaults to 1.0, indicating that no iteration is performed.</p> <code>1.0</code> <code>floquet_sampling_time_fraction</code> <code>float</code> <p>What point of the drive period we want to sample the Floquet modes. Defaults to 0.0, indicating the floquet modes at t=0*T where T is the drive period.</p> <code>0.0</code> <code>fit_cutoff</code> <code>int</code> <p>Cutoff for the fit polynomial of the displaced state. Defaults to 4.</p> <code>4</code> <code>overlap_cutoff</code> <code>float</code> <p>Cutoff for fitting overlaps. Floquet modes with overlap with the \"bare\" state below this cutoff are not included in the fit (as they may be experiencing a resonance). Defaults to 0.8.</p> <code>0.8</code> <code>nsteps</code> <code>int</code> <p>QuTiP integration parameter, number of steps the solver can take. Defaults to 30_000.</p> <code>30000</code> <code>num_cpus</code> <code>int</code> <p>Number of cpus to use in parallel computation of Floquet modes over the different values of omega_d, amp. Defaults to 1.</p> <code>1</code> <code>save_floquet_modes</code> <code>bool</code> <p>Indicating whether to save the extracted Floquet modes themselves. Such data is often unnecessary and requires a fair amount of storage, so the default is False.</p> <code>False</code>"},{"location":"floquet/#floquet.options.Options.fit_range_fraction","title":"<code>fit_range_fraction = fit_range_fraction</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.options.Options.floquet_sampling_time_fraction","title":"<code>floquet_sampling_time_fraction = floquet_sampling_time_fraction</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.options.Options.fit_cutoff","title":"<code>fit_cutoff = fit_cutoff</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.options.Options.overlap_cutoff","title":"<code>overlap_cutoff = overlap_cutoff</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.options.Options.nsteps","title":"<code>nsteps = nsteps</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.options.Options.num_cpus","title":"<code>num_cpus = num_cpus</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.options.Options.save_floquet_modes","title":"<code>save_floquet_modes = save_floquet_modes</code>  <code>instance-attribute</code>","text":""},{"location":"floquet/#floquet.options.Options.__init__","title":"<code>__init__(fit_range_fraction: float = 1.0, floquet_sampling_time_fraction: float = 0.0, fit_cutoff: int = 4, overlap_cutoff: float = 0.8, nsteps: int = 30000, num_cpus: int = 1, save_floquet_modes: bool = False)</code>","text":""},{"location":"floquet/#floquet.options.Options.__new__","title":"<code>__new__(*args, **kwargs) -&gt; Serializable</code>","text":"<p>Records which parameters should be saved so they can be passed to init.</p>"},{"location":"floquet/#floquet.options.Options.__eq__","title":"<code>__eq__(other: Serializable) -&gt; bool</code>","text":""},{"location":"floquet/#floquet.options.Options.__hash__","title":"<code>__hash__() -&gt; int</code>","text":""},{"location":"floquet/#floquet.options.Options.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"floquet/#floquet.options.Options.serialize","title":"<code>serialize() -&gt; dict</code>","text":"<p>Serialize a class so that it is ready to be written.</p> <p>This method creates nested dictionaries appropriate for writing to h5 files. Importantly, we save metadata associated with the class itself and any classes it takes as input so that they can be reinstantiated later.</p> <p>Returns:</p> Name Type Description <code>initdata</code> <code>dict</code> <p>Dictionary of data to save, in a format appropriate to pass to h5</p>"},{"location":"floquet/#floquet.options.Options.write_to_file","title":"<code>write_to_file(filepath: str | pathlib.Path, data_dict: dict | None = None)</code>","text":"<p>Write a class and associated data to file.</p> <p>The goal is to be able to read back both the data that was saved and all of the data necessary to reinitialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>Path to the file where we want to save the data. Must be an h5 or h5py file</p> required <code>data_dict</code> <code>dict | None</code> <p>Dictionary containing various raw data to save</p> <code>None</code>"},{"location":"floquet/#file-utilities","title":"File utilities","text":""},{"location":"floquet/#floquet.utils.file_io.Serializable","title":"<code>Serializable</code>","text":"<p>Mixin class for reading and writing to file using h5py.</p>"},{"location":"floquet/#floquet.utils.file_io.Serializable.__new__","title":"<code>__new__(*args, **kwargs) -&gt; Serializable</code>","text":"<p>Records which parameters should be saved so they can be passed to init.</p>"},{"location":"floquet/#floquet.utils.file_io.Serializable.__eq__","title":"<code>__eq__(other: Serializable) -&gt; bool</code>","text":""},{"location":"floquet/#floquet.utils.file_io.Serializable.__hash__","title":"<code>__hash__() -&gt; int</code>","text":""},{"location":"floquet/#floquet.utils.file_io.Serializable.__str__","title":"<code>__str__() -&gt; str</code>","text":""},{"location":"floquet/#floquet.utils.file_io.Serializable.serialize","title":"<code>serialize() -&gt; dict</code>","text":"<p>Serialize a class so that it is ready to be written.</p> <p>This method creates nested dictionaries appropriate for writing to h5 files. Importantly, we save metadata associated with the class itself and any classes it takes as input so that they can be reinstantiated later.</p> <p>Returns:</p> Name Type Description <code>initdata</code> <code>dict</code> <p>Dictionary of data to save, in a format appropriate to pass to h5</p>"},{"location":"floquet/#floquet.utils.file_io.Serializable.write_to_file","title":"<code>write_to_file(filepath: str | pathlib.Path, data_dict: dict | None = None)</code>","text":"<p>Write a class and associated data to file.</p> <p>The goal is to be able to read back both the data that was saved and all of the data necessary to reinitialize the class.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>Path to the file where we want to save the data. Must be an h5 or h5py file</p> required <code>data_dict</code> <code>dict | None</code> <p>Dictionary containing various raw data to save</p> <code>None</code>"},{"location":"floquet/#floquet.utils.file_io.read_from_file","title":"<code>read_from_file(filepath: str | pathlib.Path) -&gt; tuple[Serializable, dict]</code>","text":"<p>Read a class and associated data from file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str | Path</code> <p>Path to the file containing both raw data and the information needed to reinitialize our class</p> required <p>Returns:</p> Name Type Description <code>new_class_instance</code> <code>Serializable</code> <p>Class that inherits from Serializable that was earlier written with its method write_to_file</p> <code>data_dict</code> <code>dict</code> <p>Dictionary of data that was passed to write_to_file at the time</p>"},{"location":"floquet/#floquet.utils.file_io.get_init_params","title":"<code>get_init_params(obj: Serializable) -&gt; list[str]</code>","text":"<p>Returns a list of parameters entering <code>__init__</code> of <code>obj</code>.</p>"},{"location":"floquet/#floquet.utils.file_io.generate_file_path","title":"<code>generate_file_path(extension: str, file_name: str, path: str) -&gt; str</code>","text":""},{"location":"examples/EJ_sweep/","title":"Qubit parameter sweep","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport qutip as qt\nimport scqubits as scq\nfrom cycler import cycler\n\nimport floquet as ft\n\n\ncolor_cycler = cycler(plt.rcParams[\"axes.prop_cycle\"])\nls_cycler = cycler(ls=[\"-\", \"--\", \"-.\", \":\"])\nalpha_cycler = cycler(alpha=[1.0, 0.6, 0.2])\ncolor_ls_alpha_cycler = alpha_cycler * ls_cycler * color_cycler\n</code></pre> <pre><code>filepath = ft.generate_file_path(\"h5py\", \"transmon_EJ_sweep_floquet\", \"out\")\n\nnum_states = 20\nqubit_params = {\"EJ\": 20.0, \"EC\": 0.2, \"ng\": 0.25, \"ncut\": 41}\ntmon = scq.Transmon(**qubit_params, truncated_dim=num_states)\nstate_indices = [0, 1]\n\n# fix the drive frequency (\"cavity\" frequency) to a single value\nomega_d_values = 2.0 * np.pi * np.array([8.0])\nchi_ac_values = 2.0 * np.pi * np.linspace(0.0, 0.1, 59)\n\n\ndef get_H0_H1(qubit_instance: scq.GenericQubit) -&gt; tuple[qt.Qobj, qt.Qobj]:\n    hilbert_space = scq.HilbertSpace([qubit_instance])\n    hilbert_space.generate_lookup()\n    evals = hilbert_space[\"evals\"][0][0:num_states]\n    H0 = 2.0 * np.pi * qt.Qobj(np.diag(evals - evals[0]))\n    H1 = hilbert_space.op_in_dressed_eigenbasis(qubit_instance.n_operator)\n    return H0, H1\n\n\n# we define this function which takes EJ as input so that we can parallelize calls\ndef sweep_tmon_EJ(EJ: float) -&gt; tuple[np.ndarray, np.ndarray]:\n    _qubit_params = {\"EJ\": EJ, \"EC\": 0.2, \"ng\": 0.25, \"ncut\": 41}\n    _tmon = scq.Transmon(**_qubit_params, truncated_dim=num_states)\n    _H0, _H1 = get_H0_H1(_tmon)\n    _chi_to_amp = ft.ChiacToAmp(_H0, _H1, state_indices, omega_d_values)\n    _drive_amplitudes = _chi_to_amp.amplitudes_for_omega_d(chi_ac_values)\n    _model = ft.Model(\n        _H0, _H1, omega_d_values=omega_d_values, drive_amplitudes=_drive_amplitudes\n    )\n    _floquet_analysis = ft.FloquetAnalysis(_model, state_indices=state_indices)\n    _data_vals = _floquet_analysis.run(filepath=None)\n    return _data_vals[\"displaced_state_overlaps\"], _data_vals[\"avg_excitation\"]\n</code></pre> <pre><code># parallelize the calls to sweep_tmon_EJ\nEJ_values = np.linspace(15.0, 25.0, 120)\nresult = list(ft.parallel_map(6, sweep_tmon_EJ, EJ_values))\ndisplaced_state_overlaps, avg_excitation = list(zip(*result, strict=True))\n</code></pre> <pre><code>tmon_idx = 1\nEJ_idx = 3\n\n# indices are EJ, omega_d, amp, tmon state\nplot_data = np.clip(\n    1 - np.array(displaced_state_overlaps)[:, 0, :, tmon_idx].T ** 2, 0.0, 0.5\n)\nfig, ax = plt.subplots(figsize=(8, 8))\nxticks = EJ_values\nyticks = chi_ac_values / (2.0 * np.pi)\nnum_x_pts = len(xticks)\nnum_y_pts = len(yticks)\nim = plt.imshow(\n    plot_data, origin=\"lower\", cmap=\"Blues\", aspect=0.75, interpolation=\"none\"\n)\nplt.axvline(EJ_idx, color=\"grey\", ls=\"--\")\nax.set_title(f\"$P_{tmon_idx}$\" + r\"$\\rightarrow$\", fontsize=15)\nxticklabel_locations = np.linspace(0, num_x_pts - 1, 6, dtype=int)\nax.set_xticks(xticklabel_locations)\nax.set_xticklabels(\n    np.array(np.around(xticks[xticklabel_locations], decimals=2), dtype=str),\n    fontsize=12,\n)\nyticklabel_locations = np.linspace(0, num_y_pts - 1, 3, dtype=int)\nax.set_yticks(yticklabel_locations)\nax.set_yticklabels(\n    np.array(np.around(yticks[yticklabel_locations], decimals=2), dtype=str),\n    fontsize=12,\n)\nax.set_ylabel(r\"$\\chi_{\\rm ac}$ [GHz]\", fontsize=15)\nax.set_xlabel(r\"$EJ$ [GHz]\", fontsize=15)\ncax = plt.axes([0.91, 0.35, 0.05, 0.3])\ncbar = plt.colorbar(im, cax=cax)\nplt.show()\n</code></pre> 2024-10-22T15:49:35.445634 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <pre><code>fig, ax = plt.subplots(figsize=(6, 4))\nfor curve_idx, sty in zip(range(num_states), color_ls_alpha_cycler, strict=False):\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        np.array(avg_excitation)[EJ_idx, 0, :, curve_idx],\n        label=curve_idx,\n        **sty,\n    )\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.set_ylabel(r\"$N_{t}$\")\nax.legend(fontsize=12, ncol=2, loc=\"upper left\", bbox_to_anchor=(1, 1))\nplt.tight_layout()\nplt.show()\n</code></pre> 2024-10-22T15:49:38.450703 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/"},{"location":"examples/EJ_sweep/#ej-sweep-floquet-analysis","title":"EJ sweep Floquet analysis","text":"<p>Following up the previous transmon demo, we examine the possible experimental situation where the cavity frequency to use is fixed and we instead have the freedom to sweep a transmon parameter. Here specifically we fix the transmon EC and sweep EJ.</p>"},{"location":"examples/fluxonium/","title":"Fluxonium","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport qutip as qt\nimport scqubits as scq\nfrom cycler import cycler\n\nimport floquet as ft\n\n\ncolor_cycler = cycler(plt.rcParams[\"axes.prop_cycle\"])\nls_cycler = cycler(ls=[\"-\", \"--\", \"-.\", \":\"])\nalpha_cycler = cycler(alpha=[1.0, 0.6, 0.2])\ncolor_ls_alpha_cycler = alpha_cycler * ls_cycler * color_cycler\n</code></pre> <pre><code>filepath = ft.generate_file_path(\"h5py\", \"fluxonium_floquet\", \"out\")\n\n# Fluxonium parameters\nnum_states = 20\nqubit_params = {\"EJ\": 10.0, \"EC\": 1.0, \"EL\": 1.0, \"flux\": 0.5, \"cutoff\": 110}\nfluxonium = scq.Fluxonium(**qubit_params, truncated_dim=num_states)\nstate_indices = [0, 1]  # get data for ground and first excited states\n\n\n# Express operators in eigenbasis of transmon\ndef get_H0_H1(qubit_instance: scq.GenericQubit) -&gt; tuple[qt.Qobj, qt.Qobj]:\n    hilbert_space = scq.HilbertSpace([qubit_instance])\n    hilbert_space.generate_lookup()\n    evals = hilbert_space[\"evals\"][0][0:num_states]\n    H0 = 2.0 * np.pi * qt.Qobj(np.diag(evals - evals[0]))\n    H1 = hilbert_space.op_in_dressed_eigenbasis(qubit_instance.n_operator)\n    return H0, H1\n\n\nH0, H1 = get_H0_H1(fluxonium)\n\nomega_d_values = 2.0 * np.pi * np.linspace(7.7, 10.0, 120)\nchi_ac_values = 2.0 * np.pi * np.linspace(0.0, 0.2, 89)\nchi_to_amp = ft.ChiacToAmp(H0, H1, state_indices, omega_d_values)\ndrive_amplitudes = chi_to_amp.amplitudes_for_omega_d(chi_ac_values)\n\nmodel = ft.Model(\n    H0, H1, omega_d_values=omega_d_values, drive_amplitudes=drive_amplitudes\n)\noptions = ft.Options(num_cpus=6, fit_range_fraction=0.5)\n</code></pre> <pre><code>floquet_analysis_flux = ft.FloquetAnalysis(\n    model, state_indices=state_indices, options=options\n)\ndata_vals_flux = floquet_analysis_flux.run(filepath=filepath)\n</code></pre> <pre><code>fluxonium_idx = 1\nomega_d_idx = 83  # 19\n\nplot_data_flux = np.clip(\n    1 - data_vals_flux[\"displaced_state_overlaps\"][:, :, fluxonium_idx].T ** 2, 0.0, 0.5\n)\nfig, ax = plt.subplots(figsize=(8, 8))\nxticks = omega_d_values / (2.0 * np.pi)\nyticks = chi_ac_values / (2.0 * np.pi)\nnum_x_pts = len(xticks)\nnum_y_pts = len(yticks)\nim = plt.imshow(\n    plot_data_flux, origin=\"lower\", cmap=\"Blues\", aspect=0.55, interpolation=\"none\"\n)\nplt.axvline(omega_d_idx, color=\"grey\", ls=\"--\")\nax.set_title(f\"$P_{fluxonium_idx}$\" + r\"$\\rightarrow$\", fontsize=15)\nxticklabel_locations = np.linspace(0, num_x_pts - 1, 6, dtype=int)\nax.set_xticks(xticklabel_locations)\nax.set_xticklabels(\n    np.array(np.around(xticks[xticklabel_locations], decimals=2), dtype=str),\n    fontsize=12,\n)\nyticklabel_locations = np.linspace(0, num_y_pts - 1, 3, dtype=int)\nax.set_yticks(yticklabel_locations)\nax.set_yticklabels(\n    np.array(np.around(yticks[yticklabel_locations], decimals=2), dtype=str),\n    fontsize=12,\n)\nax.set_ylabel(r\"$\\chi_{\\rm ac}$ [GHz]\", fontsize=15)\nax.set_xlabel(r\"$\\omega_r/2\\pi$ [GHz]\", fontsize=15)\ncax = plt.axes([0.91, 0.35, 0.05, 0.3])\ncbar = plt.colorbar(im, cax=cax)\nplt.show()\n</code></pre> 2024-10-18T14:06:54.375345 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <p>At the linecut position we observe a resonance. Lets compare with the Blais results to determine the state that is responsible.</p> <pre><code>fig, ax = plt.subplots(figsize=(6, 3.5))\nfor curve_idx, sty in zip(range(num_states), color_ls_alpha_cycler, strict=False):\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        data_vals_flux[\"avg_excitation\"][omega_d_idx, :, curve_idx],\n        label=curve_idx,\n        **sty,\n    )\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.set_ylabel(r\"$N_{f}$\")\nax.legend(fontsize=12, ncol=2, loc=\"upper left\", bbox_to_anchor=(1, 1))\n# ax.set_ylim(-27 / 2 / np.pi, -20 / 2 / np.pi)\nplt.tight_layout()\nplt.show()\n</code></pre> 2024-10-18T14:08:32.379380 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <p>We see its the eighth excited state. Looking at the quasienergies confirms an avoided crossing (with tens of MHz strength!)</p> <pre><code>fig, ax = plt.subplots(figsize=(6, 3.5))\nfor curve_idx, sty in zip(range(num_states), color_ls_alpha_cycler, strict=False):\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        data_vals_flux[\"quasienergies\"][omega_d_idx, :, curve_idx] / 2 / np.pi,\n        label=curve_idx,\n        **sty,\n    )\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.set_ylabel(\"quasienergies [GHz]\")\nax.legend(fontsize=12, ncol=2, loc=\"upper left\", bbox_to_anchor=(1, 1))\nax.set_ylim(0.0, 0.3)\nplt.tight_layout()\nplt.show()\n</code></pre> 2024-10-18T14:09:33.332879 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/"},{"location":"examples/fluxonium/#fluxonium-floquet-analysis","title":"Fluxonium Floquet analysis","text":"<p>How easy is it to apply the Floquet analysis to a different qubit type? As easy as initializing another qubit that is already implemented in <code>scqubits</code>. Below we plot the displaced state overlap plot, as well as the branch analysis and quasienergies.</p>"},{"location":"examples/parametric/","title":"Parametric driving","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport qutip as qt\nimport scqubits as scq\nfrom cycler import cycler\n\nimport floquet as ft\n\n\ncolor_cycler = cycler(plt.rcParams[\"axes.prop_cycle\"])\nls_cycler = cycler(ls=[\"-\", \"--\", \"-.\", \":\"])\nalpha_cycler = cycler(alpha=[1.0, 0.6, 0.2])\ncolor_ls_alpha_cycler = alpha_cycler * ls_cycler * color_cycler\n</code></pre> <pre><code>filepath = ft.generate_file_path(\"h5py\", \"transmon_parametric_floquet\", \"out\")\n\nnum_states = 20\nqubit_params = {\"EJ\": 20.0, \"EC\": 0.2, \"ng\": 0.25, \"ncut\": 41}\ntmon = scq.Transmon(**qubit_params, truncated_dim=num_states)\nstate_indices = [0, 1]\n\n\n# Express operators in eigenbasis of transmon\ndef get_H0_H1(qubit_instance: scq.GenericQubit) -&gt; tuple[qt.Qobj, qt.Qobj]:\n    hilbert_space = scq.HilbertSpace([qubit_instance])\n    hilbert_space.generate_lookup()\n    evals = hilbert_space[\"evals\"][0][0:num_states]\n    H0 = 2.0 * np.pi * qt.Qobj(np.diag(evals - evals[0]))\n    H1 = hilbert_space.op_in_dressed_eigenbasis(qubit_instance.n_operator)\n    return H0, H1\n\n\nH0, H1 = get_H0_H1(tmon)\n\nomega_d_values = 2.0 * np.pi * np.linspace(1.5, 2.0, 60)\nchi_ac_values = 2.0 * np.pi * np.linspace(0.0, 0.8, 59)\nchi_to_amp = ft.ChiacToAmp(H0, H1, state_indices, omega_d_values)\ndrive_amplitudes = chi_to_amp.amplitudes_for_omega_d(chi_ac_values)\n\nmodel = ft.Model(\n    H0, H1, omega_d_values=omega_d_values, drive_amplitudes=drive_amplitudes\n)\n</code></pre> <pre><code>filepath = ft.generate_file_path(\"h5py\", \"transmon_floquet_parametric\", \"out\")\nfloquet_analysis = ft.FloquetAnalysis(\n    model, state_indices=state_indices, options=ft.Options(num_cpus=6)\n)\ndata_vals = floquet_analysis.run(filepath=filepath)\n</code></pre> <pre><code>omega_d_idx = 59\nfig, ax = plt.subplots(figsize=(6, 4))\nfor curve_idx, sty in zip(range(num_states), color_ls_alpha_cycler, strict=False):\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        np.array(data_vals[\"avg_excitation\"])[omega_d_idx, :, curve_idx],\n        label=curve_idx,\n        **sty,\n    )\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.set_ylabel(r\"$N_{t}$\")\nax.legend(fontsize=12, ncol=2, loc=\"upper left\", bbox_to_anchor=(1, 1))\nplt.tight_layout()\nplt.show()\n</code></pre> 2024-10-18T14:11:56.544168 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <pre><code>fig, ax = plt.subplots(figsize=(6, 3.5))\nfor curve_idx, sty in zip(range(3), color_ls_alpha_cycler, strict=False):\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        data_vals[\"quasienergies\"][omega_d_idx, :, curve_idx] / 2 / np.pi,\n        label=curve_idx,\n        **sty,\n    )\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.set_ylabel(\"quasienergies [GHz]\")\nax.legend(fontsize=12, ncol=2, loc=\"upper left\", bbox_to_anchor=(1, 1))\nplt.tight_layout()\nplt.show()\n</code></pre> 2024-10-18T14:11:59.108042 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/"},{"location":"examples/parametric/#parametric-pumping-below-the-qubit-frequency","title":"Parametric pumping below the qubit frequency","text":"<p>We can also apply the Floquet analysis to examine parametric driving of the transmon below its resonance frequency, which is not a typical situation for transmon readout.</p>"},{"location":"examples/transmon/","title":"Transmon","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy as np\nimport qutip as qt\nimport scqubits as scq\nfrom cycler import cycler\n\nimport floquet as ft\n\n\ncolor_cycler = cycler(plt.rcParams[\"axes.prop_cycle\"])\nls_cycler = cycler(ls=[\"-\", \"--\", \"-.\", \":\"])\nalpha_cycler = cycler(alpha=[1.0, 0.6, 0.2])\ncolor_ls_alpha_cycler = alpha_cycler * ls_cycler * color_cycler\n</code></pre> <pre><code>filepath = ft.generate_file_path(\"h5py\", \"transmon_floquet\", \"out\")\n\n# Transmon parameters\nnum_states = 20\n# These parameters give a transmon with E10 = 5.45 GHz, alpha = -219 MHz\nqubit_params = {\"EJ\": 20.0, \"EC\": 0.2, \"ng\": 0.25, \"ncut\": 41}\ntmon = scq.Transmon(**qubit_params, truncated_dim=num_states)\nstate_indices = [0, 1]  # get data for ground and first excited states\n\n\n# Express operators in eigenbasis of transmon\ndef get_H0_H1(qubit_instance: scq.GenericQubit) -&gt; tuple[qt.Qobj, qt.Qobj]:\n    hilbert_space = scq.HilbertSpace([qubit_instance])\n    hilbert_space.generate_lookup()\n    evals = hilbert_space[\"evals\"][0][0:num_states]\n    H0 = 2.0 * np.pi * qt.Qobj(np.diag(evals - evals[0]))\n    H1 = hilbert_space.op_in_dressed_eigenbasis(qubit_instance.n_operator)\n    return H0, H1\n\n\nH0, H1 = get_H0_H1(tmon)\n\n# Drive parameters\n# Drive frequencies to scan over\nomega_d_values = 2.0 * np.pi * np.linspace(7.5, 10.0, 120)\n# Induced ac stark shifts to scan over\nchi_ac_values = 2.0 * np.pi * np.linspace(0.0, 0.1, 59)\n# To achieve same range of chi_ac for the various drive frequencies, need different\n# drive amplitudes. This utility computes the linear drive strength required to achieve\n# a desired induced ac-Stark shift for the various drive frequencies.\nchi_to_amp = ft.ChiacToAmp(H0, H1, state_indices, omega_d_values)\n# drive_amplitudes has shape (a,w), where a is amplitude and w is frequency\ndrive_amplitudes = chi_to_amp.amplitudes_for_omega_d(chi_ac_values)\n\n# initialize the model to pass to FloquetAnalysis\nmodel = ft.Model(\n    H0, H1, omega_d_values=omega_d_values, drive_amplitudes=drive_amplitudes\n)\n\noptions = ft.Options(\n    fit_range_fraction=0.5,  # split the fit into segments based on this fraction\n    floquet_sampling_time_fraction=0.0,  # fraction of the period to compute the Floquet modes  # noqa E501\n    fit_cutoff=4,  # polynomial cutoff\n    overlap_cutoff=0.8,  # cutoff for excluding from the fit\n    nsteps=30_000,  # qutip integration parameter\n    num_cpus=6,  # number of cpus to use to compute Floquet modes in parallel\n    save_floquet_modes=True,  # whether or not to save floquet modes themselves\n)\n</code></pre> <pre><code>floquet_analysis = ft.FloquetAnalysis(\n    model, state_indices=state_indices, options=options\n)\ndata_vals = floquet_analysis.run(filepath=filepath)\n</code></pre> <pre><code># All of the data is saved in data_vals above, but we can also recover the data from\n# file as shown here.\n_, new_data_dict = ft.read_from_file(filepath)\n</code></pre> <pre><code>tmon_idx = 1  # Plot leakage probability for |e&gt;. Try 0 for |g&gt;\nomega_d_idx = 100  # Drive frequency where we take a linecut\n\n# Clipping the transition probability data at 0.5 gives nice-looking results.\n# try plotting \"bare_state_overlaps\" or \"intermediate_state_overlaps\" instead of\n# \"displaced_state_overlaps\" to look at the overlaps with the bare state or the\n# displaced state obtained from fitting the intermediate amplitude regions,\n# respectively. In the bare_state_overlaps results you can clearly see the effects of\n# the ac stark shift, causing deviation of the floquet mode from the bare state\n# even in the absence of a resonance.\nplot_data = np.clip(\n    1 - new_data_dict[\"displaced_state_overlaps\"][:, :, tmon_idx].T ** 2, 0.0, 0.5\n)\nfig, ax = plt.subplots(figsize=(8, 8))\nxticks = omega_d_values / (2.0 * np.pi)\nyticks = chi_ac_values / (2.0 * np.pi)\nnum_x_pts = len(xticks)\nnum_y_pts = len(yticks)\nim = plt.imshow(\n    plot_data, origin=\"lower\", cmap=\"Blues\", aspect=0.75, interpolation=\"none\"\n)\nplt.axvline(omega_d_idx, color=\"grey\", ls=\"--\")\nax.set_title(f\"$P_{tmon_idx}$\" + r\"$\\rightarrow$\", fontsize=15)\nxticklabel_locations = np.linspace(0, num_x_pts - 1, 6, dtype=int)\nax.set_xticks(xticklabel_locations)\nax.set_xticklabels(\n    np.array(np.around(xticks[xticklabel_locations], decimals=2), dtype=str),\n    fontsize=12,\n)\nyticklabel_locations = np.linspace(0, num_y_pts - 1, 3, dtype=int)\nax.set_yticks(yticklabel_locations)\nax.set_yticklabels(\n    np.array(np.around(yticks[yticklabel_locations], decimals=2), dtype=str),\n    fontsize=12,\n)\nax.set_ylabel(r\"$\\chi_{\\rm ac}$ [GHz]\", fontsize=15)\nax.set_xlabel(r\"$\\omega_r/2\\pi$ [GHz]\", fontsize=15)\ncax = plt.axes([0.91, 0.35, 0.05, 0.3])\ncbar = plt.colorbar(im, cax=cax)\nplt.show()\n</code></pre> 2024-10-17T16:52:07.084036 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <p>This plot gives us a \"birds-eye\" view of ionization. Anywhere we see white, the Floquet mode agrees with the \"ideal displaced state.\" Anywhere we see blue, those two do not agree and we interpret this as a nonlinear resonance (or \"ionization\"). At the linecut specified by the grey dashed line, we see that the first excited state goes through two separate resonances.</p> <pre><code>fig, ax = plt.subplots(figsize=(6, 3.5))\nfor curve_idx, sty in zip(\n    range(floquet_analysis.hilbert_dim), color_ls_alpha_cycler, strict=False\n):\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        new_data_dict[\"avg_excitation\"][omega_d_idx, :, curve_idx],\n        label=curve_idx,\n        **sty,\n    )\nax.set_ylabel(r\"$N_{t}$\")\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.legend(fontsize=12, ncol=2, loc=\"upper left\", bbox_to_anchor=(1, 1))\nplt.tight_layout()\nplt.savefig(\"branch_analysis.pdf\")\nplt.show()\n</code></pre> 2024-10-17T16:52:14.832117 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <p>We see that the branch with an average excitation number of 1 experiences two branch crossing events. The first is slightly above \\(\\chi_{\\rm ac}=0.04\\) GHz and is with the fifth excited state. The second is at \\(\\chi_{\\rm ac}=0.08\\) GHz and is with the 13th excited state. Note that the first-excited-state branch swaps with the fifth-excited-state branch after the first branch crossing: it is the fifth-excited state branch that now has an average excitation number of nearly 1 and should be identified with the first-excited state. Put another way: if in a readout experiment one approached this resonance too slowly, the first excited state would ionize up to the fifth excited transmon state.</p> <p>These two techniques are thus complementary for investigating ionization. The displaced-state technique allows us to get an overall view of the landscape of resonances, while the branch-crossing technique allows us to investigate which states are responsible for the resonances. They also helpfully provide a check on one another: aside from the computation of the Floquet modes themselves, they are computed in totally different manners.</p> <pre><code>fig, ax = plt.subplots(figsize=(6, 3.5))\nfor curve_idx, sty in zip(\n    range(floquet_analysis.hilbert_dim), color_ls_alpha_cycler, strict=False\n):\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        new_data_dict[\"quasienergies\"][omega_d_idx, :, curve_idx] / 2 / np.pi,\n        label=curve_idx,\n        **sty,\n    )\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.set_ylabel(\"quasienergies [GHz]\")\nax.legend(fontsize=12, ncol=2, loc=\"upper left\", bbox_to_anchor=(1, 1))\nax.set_ylim(-27 / 2 / np.pi, -20 / 2 / np.pi)\nplt.tight_layout()\nplt.show()\n</code></pre> 2024-10-17T16:52:30.359070 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <p>Its nice to verify that the \\(\\chi_{\\rm ac}\\) we think we are inducing on the transmon is the actual induced \\(\\chi_{\\rm ac}\\) as extracted from the change in quasienergy differences.</p> <pre><code>fig, ax = plt.subplots(figsize=(6, 3.5))\ne1 = new_data_dict[\"quasienergies\"][omega_d_idx, :, 1] / 2 / np.pi\ne0 = new_data_dict[\"quasienergies\"][omega_d_idx, :, 0] / 2 / np.pi\nplt.plot(chi_ac_values / 2 / np.pi, e0 - e1 - (e0 - e1)[0], label=\"actual\")\nplt.plot(\n    chi_ac_values / 2 / np.pi,\n    chi_ac_values / 2 / np.pi,\n    color=\"grey\",\n    ls=\"--\",\n    label=\"predicted\",\n)\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.set_ylabel(r\"$e_{01}$ [GHz]\")\nax.legend()\nplt.tight_layout()\nplt.show()\n</code></pre> 2024-10-17T16:52:44.445986 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <p>We see that for small \\(\\chi_{\\rm ac}\\), the induced \\(\\chi_{\\rm ac}\\) and the predicted \\(\\chi_{\\rm ac}\\) are bang on. The quasienergies are tracked using the Blais state-tracking technique, which is why we see the deviation beginning at \\(\\chi_{\\rm ac}=0.04\\) GHz due to the branch crossing that occurs at that location.</p> <pre><code>omega_d = omega_d_values[omega_d_idx]\ndisplaced_state = ft.DisplacedState(\n    hilbert_dim=floquet_analysis.hilbert_dim,\n    model=model,\n    state_indices=state_indices,\n    options=options,\n)\n\n\ndef state_for_amp(amp: float) -&gt; qt.Qobj:\n    return displaced_state.displaced_state(\n        omega_d, amp, tmon_idx, new_data_dict[\"fit_data\"][tmon_idx]\n    )\n\n\nfig, ax = plt.subplots()\nfor comp_idx, color in zip(range(10), color_cycler, strict=False):\n    ideal_state_component = [\n        np.real(\n            qt.basis(floquet_analysis.hilbert_dim, comp_idx).dag() * state_for_amp(amp)\n        )\n        for amp in drive_amplitudes[:, omega_d_idx]\n    ]\n    # Components of the true Floquet mode\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        np.real(new_data_dict[\"floquet_modes\"][omega_d_idx, :, tmon_idx, comp_idx]),\n        label=rf\"$\\langle\\widetilde{tmon_idx}|{comp_idx} \\rangle$\",\n        color=color[\"color\"],\n    )\n    # Components of the fitted state\n    plt.plot(\n        chi_ac_values / 2 / np.pi,\n        np.real(np.squeeze(ideal_state_component)),\n        ls=\"--\",\n        label=rf\"$\\langle\\widetilde{tmon_idx}|{comp_idx} \\rangle$, fit\",\n        color=color[\"color\"],\n    )\nax.legend(ncol=2, bbox_to_anchor=(1.1, 1.05))\nax.set_xlabel(\"induced ac stark shift [GHz]\")\nax.set_ylabel(\"overlap\")\nplt.show()\n</code></pre> 2024-10-17T16:54:59.179398 image/svg+xml Matplotlib v3.9.2, https://matplotlib.org/ <p>We see that the fit goes straight through the resonances, as desired!</p>"},{"location":"examples/transmon/#transmon-floquet-analysis","title":"Transmon Floquet analysis","text":"<p>In this initial demo we perform the Floquet analysis on a transmon with a readout frequency above the qubit frequency, mapping the probability of ionization as a function of drive strength and drive frequency. We then compare these simulations to Blais-style branch crossing plots, which identify the states the qubit states leak to.</p>"},{"location":"examples/transmon/#transmon-with-readout-resonator-above-the-qubit-frequency","title":"Transmon with readout resonator above the qubit frequency","text":""},{"location":"examples/transmon/#plot-the-probability-of-nonlinear-transitions","title":"Plot the probability of nonlinear transitions","text":"<p>We compute this probability for transmon states \\(|0\\rangle\\) and \\(|1\\rangle\\) (specified by <code>state_indices</code>) by comparing the Floquet modes to a fitted \"ideal displaced state,\" chosen to be a polynomial in drive frequency and amplitude (the maximum degree of this polynomial is specified by <code>fit_cutoff</code>). The displaced state is itself computed using the Floquet modes, but excluding those modes where overlap with the reference state (for instance the undriven eigenstate) is below a cutoff value (specified by <code>overlap_cutoff</code>), possibly indicating a resonance.</p> <p>In this example we perform the fit iteratively, which is necessary to explore strong drive amplitudes (where overlap with the bare eigenstate would fall below the cutoff regardless of a resonance, due to normal ac-Stark shift effects). We split the drive amplitudes into two ranges (here specified by <code>fit_range_fraction</code>). In the first range, we compare the Floquet modes to the undriven eigenstates. We then fit the ideal displaced state for this range. This fitted state is then used as the reference state for the next range of drive amplitudes.</p> <p>For more details on the theory, please see Xiao, Venkatraman et al, arXiv (2023), specifically appendices I and J.</p>"},{"location":"examples/transmon/#branch-analysis","title":"Branch analysis","text":"<p>Using the Blais branch analysis, we can identify which states are responsible for the two transitions identified above. In this analysis we track the Floquet modes step-by-step from zero drive amplitude up to the largest drive amplitude we care about. We do this by computing overlaps of the new Floquet modes with those from the previous amplitude step. Thus there is no need to worry about the \"ideal displaced state\": the states are automatically tracked.</p> <p>Having tracked and identified the Floquet modes (and associated quasienergies), we compute the average excitation number for each branch \\(\\ell\\): \\(N_{t}(\\ell)=\\sum_{j}j|\\langle j\\widetilde{|\\ell\\rangle}|^2\\), where \\(|j\\rangle\\) are the undriven eigenstates and \\(\\widetilde{|\\ell\\rangle}\\) is the Floquet mode assigned to branch \\(\\ell\\). These Floquet modes are themselves a function of drive amplitude and frequency, leading to the branch plots below.</p> <p>For more details on the theory, please see Dumas et al, arXiv (2024), Shillito et al, PR Applied (2022)</p>"},{"location":"examples/transmon/#quasienergies","title":"Quasienergies","text":"<p>Why do these branch crossing events occur? We observe that at each point where we see a branch-swapping event, there is an avoided crossing in the quasienergy spectrum. Note that the color and linestyle assigned to each above branch is the same for the associated quasienergies plotted below.</p>"},{"location":"examples/transmon/#exploring-the-fit","title":"Exploring the fit","text":"<p>The fit coefficients are returned by the analsysis, and if the Floquet modes have been saved we can plot the fitted state against the true Floquet modes.</p>"}]}